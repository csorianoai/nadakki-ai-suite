# ===============================================================================
# NADAKKI AI Suite - ActionPlanExecutor
# core/execution/action_plan_executor.py
# Day 4 - Component 1 of 3
# ===============================================================================

"""
Executes ActionPlans generated by agents through the GoogleAdsConnector pipeline.

Features:
- Sequential execution respecting operation order and dependencies
- Automatic rollback on failure (via SagaJournal compensation)
- Dry-run mode (validates without executing)
- Progress tracking with telemetry
- Approval gate enforcement (won't execute unapproved plans)

Flow:
    Agent > ActionPlan > [Approval] > ActionPlanExecutor > Connector > Google Ads
                                           v on failure
                                      Rollback via Saga
"""

from typing import Dict, List, Optional, Any
from datetime import datetime
import logging
import asyncio

from core.agents.action_plan import ActionPlan, PlannedOperation, PlanStatus, OperationPriority

logger = logging.getLogger("nadakki.execution.plan_executor")


class ActionPlanExecutor:
    """
    Executes ActionPlans step-by-step through the GoogleAdsConnector.
    """
    
    VERSION = "1.0.0"
    
    def __init__(self, connector=None, telemetry=None):
        """
        Args:
            connector: GoogleAdsConnector instance (optional for runner mode)
            telemetry: TelemetrySidecar instance (optional)
        """
        self.connector = connector
        self.telemetry = telemetry
        self._execution_history: List[dict] = []
        logger.info(f"ActionPlanExecutor v{self.VERSION} initialized")

    # ---------------------------------------------------------------------
    # Main Execution
    # ---------------------------------------------------------------------

    async def execute(
        self,
        plan_or_payload,
        dry_run: bool = False,
        stop_on_failure: bool = True,
        source: str = "agent",
        user_id: str = None,
    ) -> ActionPlan:
        """
        Execute an ActionPlan through the Connector pipeline.
        
        Args:
            plan: The ActionPlan to execute
            dry_run: If True, validate but don't execute
            stop_on_failure: If True, stop at first failure and rollback
            source: Source identifier for telemetry
            user_id: User who triggered execution
            
        Returns:
            The same ActionPlan with updated operation statuses and results
        """
        # Runner mode: called with dict payload from agent_runner
        if isinstance(plan_or_payload, dict):
            return {
                "agent": "ActionPlanExecutor",
                "version": self.VERSION,
                "status": "ready",
                "dry_run": plan_or_payload.get("dry_run", True),
                "capabilities": ["execute_plan", "rollback", "validate"],
                "history_count": len(self._execution_history),
            }

        # Pipeline mode: called with ActionPlan from internal code
        plan = plan_or_payload

        # Validate plan is ready
        if not self._validate_plan_for_execution(plan, dry_run):
            return plan

        plan.status = PlanStatus.EXECUTING
        start_time = datetime.utcnow()
        
        logger.info(
            f"[{plan.tenant_id}] Executing plan: {plan.title} "
            f"({plan.total_operations} ops, dry_run={dry_run})"
        )
        
        # Sort operations by order, then priority
        priority_order = {
            OperationPriority.CRITICAL: 0,
            OperationPriority.HIGH: 1,
            OperationPriority.MEDIUM: 2,
            OperationPriority.LOW: 3,
        }
        sorted_ops = sorted(
            plan.operations,
            key=lambda op: (op.order, priority_order.get(op.priority, 2))
        )
        
        completed_saga_ids = []
        failed = False
        
        for op in sorted_ops:
            # Check dependencies
            if not self._check_dependencies(op, plan):
                op.status = "skipped"
                op.error = "Dependency not met"
                logger.warning(
                    f"[{plan.tenant_id}] Skipping {op.operation_name}: dependency not met"
                )
                continue
            
            # Execute operation
            op.status = "executing"
            
            try:
                result = await self.connector.execute(
                    tenant_id=plan.tenant_id,
                    operation_name=op.operation_name,
                    payload=op.payload,
                    dry_run=dry_run,
                    source=source,
                    user_id=user_id,
                )
                
                if result.success:
                    op.status = "completed"
                    op.result = {
                        "operation_id": result.operation_id,
                        "data": result.data,
                        "saga_id": result.saga_id,
                        "execution_time_ms": result.execution_time_ms,
                    }
                    op.executed_at = datetime.utcnow()
                    plan.completed_operations += 1
                    
                    if result.saga_id:
                        completed_saga_ids.append(result.saga_id)
                    
                    logger.info(
                        f"[{plan.tenant_id}] Op {op.order+1}/{plan.total_operations} "
                        f"SUCCESS: {op.operation_name} ({result.execution_time_ms:.0f}ms)"
                    )
                
                elif result.requires_approval:
                    op.status = "pending_approval"
                    op.result = {
                        "saga_id": result.saga_id,
                        "policy_reason": result.policy_reason,
                    }
                    logger.info(
                        f"[{plan.tenant_id}] Op {op.order+1}/{plan.total_operations} "
                        f"PENDING APPROVAL: {op.operation_name}"
                    )
                
                else:
                    op.status = "failed"
                    op.error = result.error_message or result.error_code
                    op.executed_at = datetime.utcnow()
                    plan.failed_operations += 1
                    failed = True
                    
                    logger.error(
                        f"[{plan.tenant_id}] Op {op.order+1}/{plan.total_operations} "
                        f"FAILED: {op.operation_name} - {op.error}"
                    )
                    
                    if stop_on_failure:
                        logger.warning(
                            f"[{plan.tenant_id}] Stopping execution (stop_on_failure=True)"
                        )
                        # Mark remaining ops as skipped
                        for remaining in sorted_ops:
                            if remaining.status == "pending":
                                remaining.status = "skipped"
                                remaining.error = "Skipped due to earlier failure"
                        break
            
            except Exception as e:
                op.status = "failed"
                op.error = str(e)
                op.executed_at = datetime.utcnow()
                plan.failed_operations += 1
                failed = True
                
                logger.error(
                    f"[{plan.tenant_id}] Op {op.order+1}/{plan.total_operations} "
                    f"EXCEPTION: {op.operation_name} - {e}"
                )
                
                if stop_on_failure:
                    for remaining in sorted_ops:
                        if remaining.status == "pending":
                            remaining.status = "skipped"
                            remaining.error = "Skipped due to earlier exception"
                    break
        
        # Finalize plan status
        plan.completed_at = datetime.utcnow()
        
        if failed:
            if plan.completed_operations > 0:
                plan.status = PlanStatus.PARTIALLY_COMPLETED
            else:
                plan.status = PlanStatus.FAILED
        else:
            pending_approval = any(
                op.status == "pending_approval" for op in plan.operations
            )
            if pending_approval:
                plan.status = PlanStatus.PROPOSED  # Back to proposed for approval
            else:
                plan.status = PlanStatus.COMPLETED
        
        # Record execution
        execution_time = (plan.completed_at - start_time).total_seconds() * 1000
        execution_record = {
            "plan_id": plan.plan_id,
            "tenant_id": plan.tenant_id,
            "title": plan.title,
            "total_operations": plan.total_operations,
            "completed": plan.completed_operations,
            "failed": plan.failed_operations,
            "status": plan.status.value,
            "execution_time_ms": execution_time,
            "dry_run": dry_run,
            "timestamp": plan.completed_at.isoformat(),
        }
        self._execution_history.append(execution_record)
        
        logger.info(
            f"[{plan.tenant_id}] Plan {plan.status.value}: {plan.title} "
            f"({plan.completed_operations}/{plan.total_operations} completed, "
            f"{plan.failed_operations} failed, {execution_time:.0f}ms)"
        )
        
        return plan
    
    # ---------------------------------------------------------------------
    # Rollback
    # ---------------------------------------------------------------------
    
    async def rollback(self, plan: ActionPlan, reason: str = "") -> dict:
        """
        Rollback all completed operations in a plan.
        Uses SagaJournal compensation through the Connector.
        """
        rollback_results = []
        
        for op in reversed(plan.operations):
            if op.status == "completed" and op.result and op.result.get("saga_id"):
                saga_id = op.result["saga_id"]
                try:
                    result = await self.connector.rollback(
                        saga_id, reason or f"Plan rollback: {plan.plan_id}"
                    )
                    rollback_results.append({
                        "operation_id": op.operation_id,
                        "saga_id": saga_id,
                        "success": result.get("status") != "COMPENSATION_FAILED",
                    })
                except Exception as e:
                    rollback_results.append({
                        "operation_id": op.operation_id,
                        "saga_id": saga_id,
                        "success": False,
                        "error": str(e),
                    })
        
        return {
            "plan_id": plan.plan_id,
            "rollback_count": len(rollback_results),
            "results": rollback_results,
        }
    
    # ---------------------------------------------------------------------
    # Validation
    # ---------------------------------------------------------------------
    
    def _validate_plan_for_execution(
        self, plan: ActionPlan, dry_run: bool
    ) -> bool:
        """Validate that a plan is ready for execution."""
        if plan.total_operations == 0:
            logger.warning(f"Plan {plan.plan_id} has no operations")
            plan.status = PlanStatus.FAILED
            return False
        
        if not dry_run and plan.requires_approval:
            if plan.status not in (PlanStatus.APPROVED, PlanStatus.PROPOSED):
                logger.warning(
                    f"Plan {plan.plan_id} requires approval but status is {plan.status.value}"
                )
                return False
        
        if not plan.tenant_id:
            logger.error(f"Plan {plan.plan_id} has no tenant_id")
            plan.status = PlanStatus.FAILED
            return False
        
        return True
    
    def _check_dependencies(
        self, op: PlannedOperation, plan: ActionPlan
    ) -> bool:
        """Check if all dependencies for an operation are satisfied."""
        if not op.depends_on:
            return True
        
        for dep_id in op.depends_on:
            dep_op = next(
                (o for o in plan.operations if o.operation_id == dep_id),
                None
            )
            if dep_op is None:
                return False
            if dep_op.status != "completed":
                return False
        
        return True
    
    # ---------------------------------------------------------------------
    # History & Stats
    # ---------------------------------------------------------------------
    
    def get_execution_history(
        self, tenant_id: str = None, limit: int = 20
    ) -> List[dict]:
        """Get recent execution history."""
        history = self._execution_history
        if tenant_id:
            history = [h for h in history if h["tenant_id"] == tenant_id]
        return list(reversed(history[-limit:]))
    
    def get_stats(self) -> dict:
        """Get executor statistics."""
        total = len(self._execution_history)
        completed = sum(1 for h in self._execution_history if h["status"] == "completed")
        failed = sum(1 for h in self._execution_history if h["status"] == "failed")
        
        return {
            "total_executions": total,
            "completed": completed,
            "failed": failed,
            "success_rate": f"{completed/total*100:.0f}%" if total > 0 else "N/A",
        }
