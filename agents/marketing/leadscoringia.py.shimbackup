# agents/lead_scoring.py - LeadScoringIA Agent
import time
from typing import Dict, List
from datetime import datetime
import sys
sys.path.append('..')
from schemas.canonical import Lead, LeadScoringOutput

class LeadScoringIA:
    def __init__(self, tenant_id: str, config: Dict = None):
        self.tenant_id = tenant_id
        self.agent_id = 'lead_scoring_ia'
        self.config = config or self._default_config()
        self.weights = self.config.get('weights', {
            'income': 0.30, 'credit_score': 0.35, 'channel': 0.20, 'engagement': 0.15
        })
        self.channel_scores = self.config.get('channel_scores', {
            'referral': 1.0, 'search': 0.85, 'landing_form': 0.70, 
            'social': 0.55, 'display': 0.40
        })

    def _default_config(self) -> Dict:
        return {
            'income_range': {'min': 0, 'max': 200000},
            'credit_range': {'min': 300, 'max': 850},
            'bucket_thresholds': {'A': 0.80, 'B': 0.60, 'C': 0.40}
        }

    def _normalize_feature(self, value: float, min_val: float, max_val: float) -> float:
        if max_val == min_val:
            return 0.5
        normalized = (value - min_val) / (max_val - min_val)
        return max(0.0, min(1.0, normalized))

    def _calculate_engagement_score(self, events: List) -> float:
        if not events:
            return 0.0
        event_weights = {
            'form_submit': 1.0, 'click': 0.5, 'pageview': 0.3, 
            'email_open': 0.4, 'call': 0.9
        }
        total = sum(event_weights.get(e.type, 0.1) for e in events)
        return min(1.0, total / 10.0)

    def _determine_bucket(self, score: float) -> str:
        th = self.config['bucket_thresholds']
        if score >= th['A']: return 'A'
        if score >= th['B']: return 'B'
        if score >= th['C']: return 'C'
        return 'D'

    def _generate_reasons(self, f: Dict[str, float], score: float) -> List[str]:
        reasons = []
        if f['income_norm'] > 0.7: reasons.append('high_income')
        if f['credit_norm'] > 0.7: reasons.append('good_credit')
        if f['channel_score'] > 0.7: reasons.append('quality_channel')
        if f['engagement'] > 0.5: reasons.append('engaged_user')
        if score < 0.4: reasons.append('low_overall_score')
        return reasons or ['standard_scoring']

    def _recommend_action(self, bucket: str) -> str:
        actions = {
            'A': 'assign_to_sales',
            'B': 'assign_to_sales',
            'C': 'nurture',
            'D': 'reject'
        }
        return actions[bucket]

    async def execute(self, lead: Lead) -> LeadScoringOutput:
        start = time.perf_counter()
        
        if lead.tenant_id != self.tenant_id:
            raise ValueError(f"Tenant mismatch: {lead.tenant_id} != {self.tenant_id}")

        attrs = lead.attributes
        income_norm = self._normalize_feature(attrs.income or 0, 0, 200000)
        credit_norm = self._normalize_feature(attrs.credit_score or 500, 300, 850)
        channel_score = self.channel_scores.get(attrs.channel, 0.3)
        engagement = self._calculate_engagement_score(lead.events)

        features = {
            'income_norm': income_norm,
            'credit_norm': credit_norm,
            'channel_score': channel_score,
            'engagement': engagement
        }
        
        score = (
            self.weights['income'] * income_norm +
            self.weights['credit_score'] * credit_norm +
            self.weights['channel'] * channel_score +
            self.weights['engagement'] * engagement
        )
        
        bucket = self._determine_bucket(score)
        reasons = self._generate_reasons(features, score)
        action = self._recommend_action(bucket)
        latency_ms = max(1, int((time.perf_counter() - start) * 1000))

        return LeadScoringOutput(
            lead_id=lead.lead_id,
            score=round(score, 3),
            bucket=bucket,
            reasons=reasons,
            recommended_action=action,
            latency_ms=latency_ms,
            tenant_id=self.tenant_id
        )

def create_agent_instance(tenant_id: str, config: Dict = None):
    return LeadScoringIA(tenant_id, config)