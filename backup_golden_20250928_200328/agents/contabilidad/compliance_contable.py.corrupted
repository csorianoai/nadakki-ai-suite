# agents/contabilidad/compliance_contable.py
"""
‚öñÔ∏è COMPLIANCE CONTABLE SUPER AGENT - NADAKKI AI SUITE
Compliance contable autom√°tico multi-jurisdicci√≥n con IA
Arquitectura: Rules Engine + Blockchain + Continuous Monitoring
Autor: Senior SaaS Architect (40 a√±os experiencia)
"""

import asyncio
import logging
import json
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Union, Any, Set
from dataclasses import dataclass, field
from enum import Enum
import hashlib
import uuid
from abc import ABC, abstractmethod

class StandardContable(Enum):
    NIIF = "NIIF"
    GAAP = "GAAP"
    LOCAL_RD = "LOCAL_RD"
    BASEL_III = "BASEL_III"

class NivelCumplimiento(Enum):
    COMPLETO = "COMPLETO"
    PARCIAL = "PARCIAL"
    NO_CUMPLE = "NO_CUMPLE"
    PENDIENTE_REVISION = "PENDIENTE_REVISION"

@dataclass
class ReglaCompliance:
    id_regla: str
    nombre: str
    descripcion: str
    standard: StandardContable
    categoria: str
    criticidad: str  # CRITICA, ALTA, MEDIA, BAJA
    formula_validacion: str
    parametros: Dict[str, Any]
    activa: bool = True
    fecha_vigencia: datetime = field(default_factory=datetime.now)
    version: str = "1.0"

@dataclass
class ResultadoValidacion:
    id_validacion: str
    regla_aplicada: ReglaCompliance
    resultado: NivelCumplimiento
    valor_calculado: Any
    valor_esperado: Any
    diferencia: Optional[float]
    observaciones: List[str]
    fecha_validacion: datetime
    requiere_accion: bool
    plazo_correccion: Optional[int]  # d√≠as

class ComplianceContableConfig:
    """Configuraci√≥n enterprise para compliance contable"""
    
    def __init__(self, config_data: Dict[str, Any]):
        self.jurisdiccion = config_data.get("jurisdiccion", "DO")
        self.standards_aplicables = [
            StandardContable(std) for std in config_data.get("standards_aplicables", ["NIIF", "LOCAL_RD"])
        ]
        self.validacion_automatica = config_data.get("validacion_automatica", True)
        self.frecuencia_validacion = config_data.get("frecuencia_validacion", "daily")
        self.alertas_tiempo_real = config_data.get("alertas_tiempo_real", True)
        self.blockchain_audit = config_data.get("blockchain_audit", True)
        self.auto_correccion = config_data.get("auto_correccion", False)
        self.integration_regulador = config_data.get("integration_regulador", True)
        self.retention_compliance = config_data.get("retention_compliance", 2555)  # 7 a√±os

class RulesEngine:
    """Motor de reglas enterprise para compliance contable"""
    
    def __init__(self):
        self.reglas = {}
        self.cache_validaciones = {}
        self._cargar_reglas_predefinidas()
    
    def _cargar_reglas_predefinidas(self):
        """Carga reglas predefinidas para diferentes standards"""
        
        # Reglas NIIF
        self.reglas["NIIF_CAR_001"] = ReglaCompliance(
            id_regla="NIIF_CAR_001",
            nombre="Provisi√≥n Adecuada de Cartera",
            descripcion="Verificar que la provisi√≥n de cartera sea adecuada seg√∫n NIIF 9",
            standard=StandardContable.NIIF,
            categoria="Cartera de Cr√©ditos",
            criticidad="CRITICA",
            formula_validacion="provision_cartera >= cartera_morosa * 0.01 + cartera_dudosa * 0.25 + cartera_irrecuperable * 1.0",
            parametros={
                "provision_minima_normal": 0.01,
                "provision_dudosa": 0.25,
                "provision_irrecuperable": 1.0
            }
        )
        
        self.reglas["NIIF_LIQ_001"] = ReglaCompliance(
            id_regla="NIIF_LIQ_001",
            nombre="Ratio de Liquidez M√≠nimo",
            descripcion="Verificar cumplimiento de ratio de liquidez m√≠nimo",
            standard=StandardContable.NIIF,
            categoria="Liquidez",
            criticidad="CRITICA",
            formula_validacion="activos_liquidos / pasivos_corto_plazo >= 1.0",
            parametros={
                "ratio_minimo": 1.0
            }
        )
        
        self.reglas["NIIF_CAP_001"] = ReglaCompliance(
            id_regla="NIIF_CAP_001",
            nombre="Adecuaci√≥n de Capital",
            descripcion="Verificar adecuaci√≥n de capital seg√∫n Basilea III",
            standard=StandardContable.BASEL_III,
            categoria="Capital",
            criticidad="CRITICA",
            formula_validacion="patrimonio_tecnico / activos_ponderados_riesgo >= 0.08",
            parametros={
                "ratio_capital_minimo": 0.08,
                "capital_tier1_minimo": 0.06
            }
        )
        
        # Reglas Rep√∫blica Dominicana
        self.reglas["LOCAL_RD_001"] = ReglaCompliance(
            id_regla="LOCAL_RD_001",
            nombre="Encaje Legal Banco Central",
            descripcion="Verificar cumplimiento encaje legal seg√∫n BCRD",
            standard=StandardContable.LOCAL_RD,
            categoria="Encaje Legal",
            criticidad="CRITICA",
            formula_validacion="depositos_bcrd >= depositos_publico * encaje_requerido",
            parametros={
                "encaje_pesos": 0.20,
                "encaje_dolares": 0.25
            }
        )
        
        self.reglas["LOCAL_RD_002"] = ReglaCompliance(
            id_regla="LOCAL_RD_002",
            nombre="L√≠mite Concentraci√≥n Crediticia",
            descripcion="Verificar l√≠mites de concentraci√≥n por deudor seg√∫n SIB",
            standard=StandardContable.LOCAL_RD,
            categoria="Concentraci√≥n",
            criticidad="ALTA",
            formula_validacion="max_exposicion_deudor / patrimonio_tecnico <= 0.25",
            parametros={
                "limite_individual": 0.25,
                "limite_grupo_economico": 0.40
            }
        )
        
        # Reglas GAAP (para instituciones con reporte US)
        self.reglas["GAAP_REC_001"] = ReglaCompliance(
            id_regla="GAAP_REC_001",
            nombre="Reconocimiento Ingresos",
            descripcion="Verificar reconocimiento adecuado de ingresos seg√∫n ASC 606",
            standard=StandardContable.GAAP,
            categoria="Ingresos",
            criticidad="ALTA",
            formula_validacion="ingresos_devengados == ingresos_contabilizados",
            parametros={
                "tolerancia_diferencia": 0.02
            }
        )
    
    def validar_regla(self, regla: ReglaCompliance, datos_financieros: Dict[str, Any]) -> ResultadoValidacion:
        """Valida una regla espec√≠fica contra datos financieros"""
        
        try:
            # Preparar contexto para evaluaci√≥n
            contexto = {**datos_financieros, **regla.parametros}
            
            # Evaluar f√≥rmula
            resultado_formula = self._evaluar_formula(regla.formula_validacion, contexto)
            
            # Determinar nivel de cumplimiento
            if isinstance(resultado_formula, bool):
                nivel = NivelCumplimiento.COMPLETO if resultado_formula else NivelCumplimiento.NO_CUMPLE
                valor_calculado = resultado_formula
                valor_esperado = True
                diferencia = None
            else:
                # Para valores num√©ricos, calcular diferencia
                valor_calculado = resultado_formula
                valor_esperado = self._obtener_valor_esperado(regla, contexto)
                diferencia = abs(valor_calculado - valor_esperado) if valor_esperado else None
                
                if diferencia is not None and diferencia <= contexto.get("tolerancia_diferencia", 0.01):
                    nivel = NivelCumplimiento.COMPLETO
                elif diferencia is not None and diferencia <= contexto.get("tolerancia_diferencia", 0.01) * 2:
                    nivel = NivelCumplimiento.PARCIAL
                else:
                    nivel = NivelCumplimiento.NO_CUMPLE
            
            # Generar observaciones
            observaciones = self._generar_observaciones(regla, nivel, valor_calculado, valor_esperado)
            
            # Determinar si requiere acci√≥n
            requiere_accion = nivel in [NivelCumplimiento.NO_CUMPLE, NivelCumplimiento.PARCIAL]
            
            # Calcular plazo de correcci√≥n
            plazo_correccion = self._calcular_plazo_correccion(regla.criticidad, nivel)
            
            return ResultadoValidacion(
                id_validacion=f"VAL_{uuid.uuid4().hex[:8]}",
                regla_aplicada=regla,
                resultado=nivel,
                valor_calculado=valor_calculado,
                valor_esperado=valor_esperado,
                diferencia=diferencia,
                observaciones=observaciones,
                fecha_validacion=datetime.now(),
                requiere_accion=requiere_accion,
                plazo_correccion=plazo_correccion
            )
            
        except Exception as e:
            return ResultadoValidacion(
                id_validacion=f"VAL_{uuid.uuid4().hex[:8]}",
                regla_aplicada=regla,
                resultado=NivelCumplimiento.PENDIENTE_REVISION,
                valor_calculado=None,
                valor_esperado=None,
                diferencia=None,
                observaciones=[f"Error en validaci√≥n: {str(e)}"],
                fecha_validacion=datetime.now(),
                requiere_accion=True,
                plazo_correccion=1
            )
    
    def _evaluar_formula(self, formula: str, contexto: Dict[str, Any]) -> Union[bool, float]:
        """Eval√∫a f√≥rmula de manera segura"""
        try:
            # Lista blanca de operaciones permitidas
            allowed_operations = {
                '+', '-', '*', '/', '(', ')', '>=', '<=', '>', '<', '==', '!=',
                'and', 'or', 'not', 'abs', 'min', 'max'
            }
            
            # Reemplazar variables en la f√≥rmula
            formula_evaluable = formula
            for variable, valor in contexto.items():
                if isinstance(valor, (int, float)):
                    formula_evaluable = formula_evaluable.replace(variable, str(valor))
            
            # Evaluar de manera segura (en producci√≥n usar un parser m√°s robusto)
            # Por simplicidad, usamos eval con contexto limitado
            return eval(formula_evaluable, {"__builtins__": {}}, contexto)
            
        except Exception as e:
            raise ValueError(f"Error evaluando f√≥rmula: {e}")
    
    def _obtener_valor_esperado(self, regla: ReglaCompliance, contexto: Dict[str, Any]) -> Optional[float]:
        """Obtiene valor esperado seg√∫n el tipo de regla"""
        if "ratio_minimo" in regla.parametros:
            return regla.parametros["ratio_minimo"]
        elif "provision_minima" in regla.parametros:
            return regla.parametros["provision_minima"]
        return None
    
    def _generar_observaciones(
        self, 
        regla: ReglaCompliance, 
        nivel: NivelCumplimiento, 
        valor_calculado: Any, 
        valor_esperado: Any
    ) -> List[str]:
        """Genera observaciones detalladas sobre la validaci√≥n"""
        
        observaciones = []
        
        if nivel == NivelCumplimiento.COMPLETO:
            observaciones.append(f"‚úÖ Cumplimiento completo de {regla.nombre}")
        elif nivel == NivelCumplimiento.PARCIAL:
            observaciones.append(f"‚ö†Ô∏è Cumplimiento parcial de {regla.nombre}")
            observaciones.append(f"Valor calculado: {valor_calculado}, Esperado: {valor_esperado}")
        elif nivel == NivelCumplimiento.NO_CUMPLE:
            observaciones.append(f"‚ùå No cumple con {regla.nombre}")
            observaciones.append(f"Valor calculado: {valor_calculado}, Esperado: {valor_esperado}")
            
            # Observaciones espec√≠ficas por tipo de regla
            if "provision" in regla.nombre.lower():
                observaciones.append("Se requiere ajuste en provisiones de cartera")
            elif "liquidez" in regla.nombre.lower():
                observaciones.append("Se requiere mejora en posici√≥n de liquidez")
            elif "capital" in regla.nombre.lower():
                observaciones.append("Se requiere fortalecimiento de capital")
        
        return observaciones
    
    def _calcular_plazo_correccion(self, criticidad: str, nivel: NivelCumplimiento) -> Optional[int]:
        """Calcula plazo de correcci√≥n en d√≠as"""
        if nivel == NivelCumplimiento.COMPLETO:
            return None
        
        if criticidad == "CRITICA":
            return 7 if nivel == NivelCumplimiento.NO_CUMPLE else 15
        elif criticidad == "ALTA":
            return 30 if nivel == NivelCumplimiento.NO_CUMPLE else 45
        elif criticidad == "MEDIA":
            return 60 if nivel == NivelCumplimiento.NO_CUMPLE else 90
        else:  # BAJA
            return 120 if nivel == NivelCumplimiento.NO_CUMPLE else 180

class BlockchainAuditTrail:
    """Sistema de auditor√≠a blockchain para trazabilidad completa"""
    
    def __init__(self):
        self.chain = []
        self.pending_transactions = []
    
    def create_genesis_block(self, tenant_id: str):
        """Crea bloque g√©nesis para un tenant"""
        genesis_block = {
            "index": 0,
            "timestamp": datetime.now().isoformat(),
            "tenant_id": tenant_id,
            "transactions": [{
                "type": "GENESIS",
                "description": f"Inicio de auditor√≠a blockchain para {tenant_id}",
                "hash": hashlib.sha256(f"genesis_{tenant_id}".encode()).hexdigest()
            }],
            "previous_hash": "0",
            "nonce": 0
        }
        
        genesis_block["hash"] = self._calculate_hash(genesis_block)
        self.chain.append(genesis_block)
        return genesis_block
    
    def add_compliance_record(
        self, 
        tenant_id: str, 
        validacion: ResultadoValidacion,
        usuario: str = "SYSTEM"
    ):
        """A√±ade registro de compliance al blockchain"""
        
        transaction = {
            "type": "COMPLIANCE_VALIDATION",
            "timestamp": datetime.now().isoformat(),
            "tenant_id": tenant_id,
            "validacion_id": validacion.id_validacion,
            "regla_id": validacion.regla_aplicada.id_regla,
            "resultado": validacion.resultado.value,
            "valor_calculado": str(validacion.valor_calculado),
            "usuario": usuario,
            "hash": hashlib.sha256(
                f"{validacion.id_validacion}_{validacion.resultado.value}_{datetime.now().isoformat()}".encode()
            ).hexdigest()
        }
        
        self.pending_transactions.append(transaction)
        
        # Crear nuevo bloque si hay suficientes transacciones
        if len(self.pending_transactions) >= 5:  # Batch de 5 transacciones
            self._create_new_block(tenant_id)
    
    def _create_new_block(self, tenant_id: str):
        """Crea nuevo bloque con transacciones pendientes"""
        
        previous_block = self.chain[-1] if self.chain else None
        
        new_block = {
            "index": len(self.chain),
            "timestamp": datetime.now().isoformat(),
            "tenant_id": tenant_id,
            "transactions": self.pending_transactions.copy(),
            "previous_hash": previous_block["hash"] if previous_block else "0",
            "nonce": 0
        }
        
        # Proof of Work simplificado
        new_block["hash"] = self._calculate_hash(new_block)
        
        self.chain.append(new_block)
        self.pending_transactions.clear()
        
        return new_block
    
    def _calculate_hash(self, block: Dict[str, Any]) -> str:
        """Calcula hash del bloque"""
        block_string = json.dumps(block, sort_keys=True, default=str)
        return hashlib.sha256(block_string.encode()).hexdigest()
    
    def verify_chain_integrity(self) -> bool:
        """Verifica integridad de la cadena"""
        for i in range(1, len(self.chain)):
            current_block = self.chain[i]
            previous_block = self.chain[i-1]
            
            if current_block["hash"] != self._calculate_hash(current_block):
                return False
            
            if current_block["previous_hash"] != previous_block["hash"]:
                return False
        
        return True
    
    def get_audit_trail(self, tenant_id: str, desde: datetime = None) -> List[Dict[str, Any]]:
        """Obtiene trail de auditor√≠a para un tenant"""
        
        audit_records = []
        
        for block in self.chain:
            if block["tenant_id"] == tenant_id:
                if desde is None or datetime.fromisoformat(block["timestamp"]) >= desde:
                    for transaction in block["transactions"]:
                        audit_records.append({
                            "block_index": block["index"],
                            "block_timestamp": block["timestamp"],
                            "transaction": transaction,
                            "block_hash": block["hash"]
                        })
        
        return audit_records

class ComplianceContable:
    """
    ‚öñÔ∏è SUPER AGENTE: COMPLIANCE CONTABLE ENTERPRISE
    
    Capacidades:
    - Validaci√≥n autom√°tica NIIF/GAAP/Local
    - Monitoreo regulaciones tiempo real
    - Blockchain audit trail inmutable
    - Auto-correcci√≥n configuraciones
    - Alertas regulatorias inteligentes
    - Reportes compliance ejecutivos
    """
    
    def __init__(self, tenant_id: str, config_path: str = None):
        self.tenant_id = tenant_id
        self.agent_id = f"compliance_contable_{tenant_id}_{uuid.uuid4().hex[:8]}"
        self.logger = ContabilidadLogger.get_logger("ComplianceContable", tenant_id)
        
        # Load Configuration
        self.config = self._load_config(config_path)
        
        # Rules Engine
        self.rules_engine = RulesEngine()
        
        # Blockchain Audit Trail
        self.blockchain_audit = BlockchainAuditTrail()
        if self.config.blockchain_audit:
            self.blockchain_audit.create_genesis_block(tenant_id)
        
        # Repository
        self.repository = TransaccionRepository()
        
        # Cache y estado
        self.ultimo_compliance_check = None
        self.alertas_activas = []
        
        # M√©tricas
        self.metrics = {
            "validaciones_realizadas": 0,
            "incumplimientos_detectados": 0,
            "auto_correcciones": 0,
            "tiempo_promedio_validacion": 0.0,
            "score_compliance_promedio": 0.0
        }
        
        self.logger.info(f"ComplianceContable inicializado para tenant {tenant_id}")
    
    def _load_config(self, config_path: str = None) -> ComplianceContableConfig:
        """Carga configuraci√≥n espec√≠fica del tenant"""
        try:
            if config_path:
                with open(config_path, 'r', encoding='utf-8') as f:
                    config_data = json.load(f)
            else:
                # Configuraci√≥n por defecto enterprise
                config_data = {
                    "jurisdiccion": "DO",
                    "standards_aplicables": ["NIIF", "LOCAL_RD"],
                    "validacion_automatica": True,
                    "frecuencia_validacion": "daily",
                    "alertas_tiempo_real": True,
                    "blockchain_audit": True,
                    "auto_correccion": False,
                    "integration_regulador": True
                }
            
            return ComplianceContableConfig(config_data)
        except Exception as e:
            self.logger.error(f"Error cargando configuraci√≥n: {e}")
            return ComplianceContableConfig({})
    
    async def ejecutar_validacion_completa(self, fecha: datetime = None) -> Dict[str, Any]:
        """Ejecuta validaci√≥n completa de compliance contable"""
        inicio_tiempo = datetime.now()
        
        if fecha is None:
            fecha = datetime.now()
        
        try:
            # 1. Obtener datos financieros
            datos_financieros = await self._obtener_datos_financieros(fecha)
            
            # 2. Obtener reglas aplicables seg√∫n configuraci√≥n
            reglas_aplicables = self._obtener_reglas_aplicables()
            
            # 3. Ejecutar validaciones
            resultados_validacion = []
            for regla in reglas_aplicables:
                resultado = self.rules_engine.validar_regla(regla, datos_financieros)
                resultados_validacion.append(resultado)
                
                # Registrar en blockchain si est√° habilitado
                if self.config.blockchain_audit:
                    self.blockchain_audit.add_compliance_record(
                        self.tenant_id, resultado, "SISTEMA_AUTOMATICO"
                    )
            
            # 4. Analizar resultados y generar score
            analisis_compliance = self._analizar_resultados_compliance(resultados_validacion)
            
            # 5. Generar alertas si es necesario
            alertas_generadas = self._generar_alertas_compliance(resultados_validacion)
            
            # 6. Ejecutar auto-correcciones si est√°n habilitadas
            correcciones_aplicadas = []
            if self.config.auto_correccion:
                correcciones_aplicadas = await self._ejecutar_auto_correcciones(resultados_validacion)
            
            # 7. Generar reporte regulatorio
            reporte_regulatorio = self._generar_reporte_regulatorio(
                resultados_validacion, analisis_compliance
            )
            
            tiempo_validacion = (datetime.now() - inicio_tiempo).total_seconds()
            self._actualizar_metricas(tiempo_validacion, resultados_validacion)
            
            resultado_completo = {
                "tenant_id": self.tenant_id,
                "fecha_validacion": fecha.isoformat(),
                "standards_evaluados": [std.value for std in self.config.standards_aplicables],
                "total_reglas_evaluadas": len(reglas_aplicables),
                "resultados_validacion": [
                    {
                        "id_validacion": r.id_validacion,
                        "regla": r.regla_aplicada.nombre,
                        "standard": r.regla_aplicada.standard.value,
                        "categoria": r.regla_aplicada.categoria,
                        "criticidad": r.regla_aplicada.criticidad,
                        "resultado": r.resultado.value,
                        "valor_calculado": r.valor_calculado,
                        "valor_esperado": r.valor_esperado,
                        "diferencia": r.diferencia,
                        "observaciones": r.observaciones,
                        "requiere_accion": r.requiere_accion,
                        "plazo_correccion": r.plazo_correccion
                    }
                    for r in resultados_validacion
                ],
                "analisis_compliance": analisis_compliance,
                "alertas_generadas": alertas_generadas,
                "correcciones_aplicadas": correcciones_aplicadas,
                "reporte_regulatorio": reporte_regulatorio,
                "blockchain_hash": self.blockchain_audit.chain[-1]["hash"] if self.config.blockchain_audit else None,
                "tiempo_validacion_segundos": tiempo_validacion,
                "fecha_generacion": datetime.now().isoformat(),
                "version_compliance": "2.0.0-enterprise"
            }
            
            self.ultimo_compliance_check = resultado_completo
            self.logger.info(f"Validaci√≥n compliance completa realizada exitosamente")
            return resultado_completo
            
        except Exception as e:
            self.logger.error(f"Error en validaci√≥n compliance: {e}")
            raise
    
    async def _obtener_datos_financieros(self, fecha: datetime) -> Dict[str, Any]:
        """Obtiene datos financieros para validaci√≥n"""
        # Obtener saldos contables
        saldos = await self.repository.get_saldos_cuentas(self.tenant_id, fecha)
        
        # Calcular m√©tricas requeridas para compliance
        datos = {
            # Activos
            "activos_totales": sum(float(v) for k, v in saldos.items() if k.startswith("1")),
            "cartera_creditos": float(saldos.get("1110001", 0)),
            "cartera_morosa": float(saldos.get("1110002", 0)),
            "cartera_dudosa": float(saldos.get("1110003", 0)),
            "cartera_irrecuperable": float(saldos.get("1110004", 0)),
            "provision_cartera": float(saldos.get("1119001", 0)),
            "activos_liquidos": float(saldos.get("1100001", 0)) + float(saldos.get("1120001", 0)),
            "inversiones": float(saldos.get("1120001", 0)),
            
            # Pasivos
            "pasivos_totales": sum(float(v) for k, v in saldos.items() if k.startswith("2")),
            "depositos_publico": float(saldos.get("2110001", 0)),
            "depositos_bcrd": float(saldos.get("1100002", 0)),  # Encaje en BCRD
            "obligaciones_financieras": float(saldos.get("2120001", 0)),
            "pasivos_corto_plazo": float(saldos.get("2110001", 0)) * 0.3,  # Estimado 30% corto plazo
            
            # Patrimonio
            "patrimonio_total": sum(float(v) for k, v in saldos.items() if k.startswith("3")),
            "patrimonio_tecnico": sum(float(v) for k, v in saldos.items() if k.startswith("3")) * 0.95,  # Ajustado
            "capital_social": float(saldos.get("3110001", 0)),
            "reservas": float(saldos.get("3120001", 0)),
            
            # Resultados
            "ingresos_operativos": float(saldos.get("4110001", 0)),
            "gastos_operativos": float(saldos.get("5110001", 0)),
            "utilidad_neta": float(saldos.get("4110001", 0)) - float(saldos.get("5110001", 0)),
            "ingresos_devengados": float(saldos.get("4110001", 0)),
            "ingresos_contabilizados": float(saldos.get("4110001", 0)),
            
            # M√©tricas espec√≠ficas para compliance
            "activos_ponderados_riesgo": sum(float(v) for k, v in saldos.items() if k.startswith("1")) * 0.75,
            "max_exposicion_deudor": float(saldos.get("1110001", 0)) * 0.15,  # Estimado 15% m√°xima exposici√≥n
            
            # Par√°metros regulatorios (Rep√∫blica Dominicana)
            "encaje_requerido": 0.20,  # 20% para pesos dominicanos
            "encaje_dolares": 0.25     # 25% para d√≥lares
        }
        
        return datos
    
    def _obtener_reglas_aplicables(self) -> List[ReglaCompliance]:
        """Obtiene reglas aplicables seg√∫n configuraci√≥n del tenant"""
        reglas_aplicables = []
        
        for regla_id, regla in self.rules_engine.reglas.items():
            if regla.standard in self.config.standards_aplicables and regla.activa:
                reglas_aplicables.append(regla)
        
        return reglas_aplicables
    
    def _analizar_resultados_compliance(self, resultados: List[ResultadoValidacion]) -> Dict[str, Any]:
        """Analiza resultados de compliance y genera m√©tricas"""
        
        total_reglas = len(resultados)
        reglas_cumplidas = len([r for r in resultados if r.resultado == NivelCumplimiento.COMPLETO])
        reglas_parciales = len([r for r in resultados if r.resultado == NivelCumplimiento.PARCIAL])
        reglas_incumplidas = len([r for r in resultados if r.resultado == NivelCumplimiento.NO_CUMPLE])
        
        # Score de compliance general
        score_compliance = (reglas_cumplidas + reglas_parciales * 0.5) / total_reglas * 100 if total_reglas > 0 else 0
        
        # An√°lisis por criticidad
        criticas_incumplidas = len([
            r for r in resultados 
            if r.resultado == NivelCumplimiento.NO_CUMPLE and r.regla_aplicada.criticidad == "CRITICA"
        ])
        
        # An√°lisis por standard
        analisis_por_standard = {}
        for standard in self.config.standards_aplicables:
            resultados_standard = [r for r in resultados if r.regla_aplicada.standard == standard]
            if resultados_standard:
                cumplidas_standard = len([r for r in resultados_standard if r.resultado == NivelCumplimiento.COMPLETO])
                score_standard = cumplidas_standard / len(resultados_standard) * 100
                analisis_por_standard[standard.value] = {
                    "total_reglas": len(resultados_standard),
                    "cumplidas": cumplidas_standard,
                    "score": score_standard
                }
        
        # An√°lisis por categor√≠a
        categorias = set(r.regla_aplicada.categoria for r in resultados)
        analisis_por_categoria = {}
        for categoria in categorias:
            resultados_categoria = [r for r in resultados if r.regla_aplicada.categoria == categoria]
            cumplidas_categoria = len([r for r in resultados_categoria if r.resultado == NivelCumplimiento.COMPLETO])
            score_categoria = cumplidas_categoria / len(resultados_categoria) * 100
            analisis_por_categoria[categoria] = {
                "total_reglas": len(resultados_categoria),
                "cumplidas": cumplidas_categoria,
                "incumplidas": len(resultados_categoria) - cumplidas_categoria,
                "score": score_categoria
            }
        
        # Determinar nivel de riesgo general
        if criticas_incumplidas > 0:
            nivel_riesgo = "CRITICO"
        elif score_compliance < 85:
            nivel_riesgo = "ALTO"
        elif score_compliance < 95:
            nivel_riesgo = "MEDIO"
        else:
            nivel_riesgo = "BAJO"
        
        return {
            "score_compliance_general": round(score_compliance, 2),
            "nivel_riesgo_compliance": nivel_riesgo,
            "total_reglas_evaluadas": total_reglas,
            "reglas_cumplidas": reglas_cumplidas,
            "reglas_parcialmente_cumplidas": reglas_parciales,
            "reglas_incumplidas": reglas_incumplidas,
            "reglas_criticas_incumplidas": criticas_incumplidas,
            "analisis_por_standard": analisis_por_standard,
            "analisis_por_categoria": analisis_por_categoria,
            "fecha_analisis": datetime.now().isoformat()
        }
    
    def _generar_alertas_compliance(self, resultados: List[ResultadoValidacion]) -> List[Dict[str, Any]]:
        """Genera alertas basadas en resultados de compliance"""
        
        alertas = []
        
        # Alertas por incumplimientos cr√≠ticos
        for resultado in resultados:
            if (resultado.resultado == NivelCumplimiento.NO_CUMPLE and 
                resultado.regla_aplicada.criticidad == "CRITICA"):
                
                alertas.append({
                    "tipo": "INCUMPLIMIENTO_CRITICO",
                    "severidad": "CRITICA",
                    "titulo": f"Incumplimiento Cr√≠tico: {resultado.regla_aplicada.nombre}",
                    "descripcion": f"Regla {resultado.regla_aplicada.id_regla} no cumplida",
                    "standard": resultado.regla_aplicada.standard.value,
                    "categoria": resultado.regla_aplicada.categoria,
                    "observaciones": resultado.observaciones,
                    "plazo_correccion": resultado.plazo_correccion,
                    "accion_requerida": "Correcci√≥n inmediata requerida",
                    "responsable": "CFO / Compliance Officer",
                    "fecha_alerta": datetime.now().isoformat()
                })
        
        # Alertas por m√∫ltiples incumplimientos en una categor√≠a
        categorias_problematicas = {}
        for resultado in resultados:
            if resultado.resultado != NivelCumplimiento.COMPLETO:
                categoria = resultado.regla_aplicada.categoria
                if categoria not in categorias_problematicas:
                    categorias_problematicas[categoria] = 0
                categorias_problematicas[categoria] += 1
        
        for categoria, count in categorias_problematicas.items():
            if count >= 2:  # 2 o m√°s incumplimientos en una categor√≠a
                alertas.append({
                    "tipo": "MULTIPLES_INCUMPLIMIENTOS",
                    "severidad": "ALTA",
                    "titulo": f"M√∫ltiples Incumplimientos en {categoria}",
                    "descripcion": f"{count} reglas incumplidas en categor√≠a {categoria}",
                    "accion_requerida": "Revisi√≥n integral de la categor√≠a",
                    "responsable": "√Årea Compliance",
                    "fecha_alerta": datetime.now().isoformat()
                })
        
        # Alertas por vencimientos pr√≥ximos
        for resultado in resultados:
            if resultado.requiere_accion and resultado.plazo_correccion and resultado.plazo_correccion <= 7:
                alertas.append({
                    "tipo": "VENCIMIENTO_PROXIMO",
                    "severidad": "MEDIA",
                    "titulo": f"Correcci√≥n Requerida: {resultado.regla_aplicada.nombre}",
                    "descripcion": f"Plazo de correcci√≥n: {resultado.plazo_correccion} d√≠as",
                    "accion_requerida": "Planificar correcciÛn inmediata",
                    "responsable": "¡rea Compliance",
                    "fecha_alerta": datetime.now().isoformat()
                })
