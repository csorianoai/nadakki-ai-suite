"""
Nadakki Enterprise JWT Authentication System
Generated by Nadakki Auto-Generator
"""
import jwt
import bcrypt
import secrets
from datetime import datetime, timedelta, timezone
from typing import Dict, Optional, List
from fastapi import HTTPException, Depends, Header
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
import redis
import os

class NadakkiJWTAuth:
    def __init__(self):
        self.secret_key = os.getenv('JWT_SECRET_KEY', secrets.token_hex(32))
        self.algorithm = 'HS256'
        self.access_token_expire_minutes = 30
        self.refresh_token_expire_days = 7
        self.redis_client = redis.Redis(
            host=os.getenv('REDIS_HOST', 'localhost'),
            port=int(os.getenv('REDIS_PORT', 6379)),
            db=0,
            decode_responses=True
        )
    
    def hash_password(self, password: str) -> str:
        """Hash password using bcrypt"""
        salt = bcrypt.gensalt()
        return bcrypt.hashpw(password.encode('utf-8'), salt).decode('utf-8')
    
    def verify_password(self, plain_password: str, hashed_password: str) -> bool:
        """Verify password against hash"""
        return bcrypt.checkpw(plain_password.encode('utf-8'), hashed_password.encode('utf-8'))
    
    def create_access_token(self, data: Dict, tenant_id: str, roles: List[str]) -> str:
        """Create JWT access token"""
        to_encode = data.copy()
        expire = datetime.now(timezone.utc) + timedelta(minutes=self.access_token_expire_minutes)
        
        to_encode.update({
            "exp": expire,
            "iat": datetime.now(timezone.utc),
            "type": "access",
            "tenant_id": tenant_id,
            "roles": roles,
            "jti": secrets.token_hex(16)
        })
        
        encoded_jwt = jwt.encode(to_encode, self.secret_key, algorithm=self.algorithm)
        
        # Store in Redis for validation
        self.redis_client.setex(
            f"token:{to_encode['jti']}", 
            self.access_token_expire_minutes * 60,
            encoded_jwt
        )
        
        return encoded_jwt
    
    def create_refresh_token(self, user_id: str, tenant_id: str) -> str:
        """Create JWT refresh token"""
        to_encode = {
            "sub": user_id,
            "tenant_id": tenant_id,
            "exp": datetime.now(timezone.utc) + timedelta(days=self.refresh_token_expire_days),
            "iat": datetime.now(timezone.utc),
            "type": "refresh",
            "jti": secrets.token_hex(16)
        }
        
        encoded_jwt = jwt.encode(to_encode, self.secret_key, algorithm=self.algorithm)
        
        # Store in Redis
        self.redis_client.setex(
            f"refresh:{to_encode['jti']}", 
            self.refresh_token_expire_days * 24 * 60 * 60,
            encoded_jwt
        )
        
        return encoded_jwt
    
    def verify_token(self, token: str) -> Dict:
        """Verify and decode JWT token"""
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
            
            # Check if token exists in Redis
            token_key = f"token:{payload.get('jti')}" if payload.get('type') == 'access' else f"refresh:{payload.get('jti')}"
            if not self.redis_client.exists(token_key):
                raise HTTPException(status_code=401, detail="Token revoked or expired")
            
            return payload
            
        except jwt.ExpiredSignatureError:
            raise HTTPException(status_code=401, detail="Token expired")
        except jwt.JWTError:
            raise HTTPException(status_code=401, detail="Invalid token")
    
    def revoke_token(self, token: str):
        """Revoke token by removing from Redis"""
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
            token_key = f"token:{payload.get('jti')}" if payload.get('type') == 'access' else f"refresh:{payload.get('jti')}"
            self.redis_client.delete(token_key)
        except:
            pass  # Token already invalid
    
    def check_permissions(self, required_roles: List[str], user_roles: List[str]) -> bool:
        """Check if user has required permissions"""
        return any(role in user_roles for role in required_roles)

# Global instance
jwt_auth = NadakkiJWTAuth()

# FastAPI Security
security = HTTPBearer()

def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """FastAPI dependency for JWT authentication"""
    token = credentials.credentials
    payload = jwt_auth.verify_token(token)
    return payload

def require_roles(required_roles: List[str]):
    """Decorator for role-based access control"""
    def role_checker(current_user: Dict = Depends(get_current_user)):
        user_roles = current_user.get('roles', [])
        if not jwt_auth.check_permissions(required_roles, user_roles):
            raise HTTPException(
                status_code=403, 
                detail=f"Insufficient permissions. Required: {required_roles}"
            )
        return current_user
    return role_checker

def require_tenant(tenant_id: str = None):
    """Decorator for tenant isolation"""
    def tenant_checker(current_user: Dict = Depends(get_current_user)):
        user_tenant = current_user.get('tenant_id')
        if tenant_id and user_tenant != tenant_id:
            raise HTTPException(
                status_code=403, 
                detail="Access denied to this tenant"
            )
        return current_user
    return tenant_checker
